<div class="blog">
    <h3>什么是散列表？</h3>
    <a href="http://www.serve.net/buz/hash.adt/java.000.html">Hashing-1</a>
    <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Hashing/">Hashing-2</a>
    以下资料摘自《算法导论》 第11章:散列表
    <h5>直接寻址表</h5>
    <p>
    直接寻址表顾名思义,就是用普通数组直接进行寻址的数组,其能在最坏O(1)时间内访问数组中的任意位置,不过它的缺点非常明显,
    当数据量比较小时,它简单有效,当比较大时,则不太实际,或者当数组空间很大而元素很少,则对空间造成了浪费。
    所以针对数组的不足,有了以下散列表,散列表是数组概念的推广,散列表即延续了数组的直接寻址快速的特点,又弥补了大数据时的不足。
    </p>
    <h5>散列表</h5>
    <p>
    在散列方式下,一个元素存放在下标h(k)中,即利用散列函数h,由关键字k计算出下标的位置,这里函数h将关键字k映射到散列表T数组的下标中,
    此处h(k)为关键字k的散列值。
    这里存在一个问题,两个关键可能映射为同一散列值,即同一下标位置上,这种情况称之为冲突,一般的解决方案为1:链接法 2:开放寻址法;
    </p>
    <h5>散列函数</h5>
    <p>
    散列函数是散列表性能的重要因素,常见的有用除法进行散列和用乘法进行散列,以及全域散列。乘/除法的散列方法比较简单,就是把当前
    的关键字先转为自然数,然后进行 取余/取模 运算或者移位运算等。
    如果一恶意对手来针对特定的散列函数选择要散列的关键字,那么他将n个关键字全部散列到同一槽中,使得平均检索时间为O(n),任何一特定
    的散列函数都可能出现这种最坏情况.唯一有效的改进方法是随机选择散列函数,使之独立于要存储的关键字,这种方法称为全域散列法。
    不管对手选择了怎样的关键字,其平均性能都很好。
    当然以上的所有散列函数都应精心设计。
    </p>
    <h5>链表法</h5>
    <p>
    链表法中把散列到同一槽中的所有元素都放在一个链表中,槽x(某一下标)中有一个指针,它指向存储所有散列到x的元素的链表的表头,
    如果不存在这样的元素,则槽x中为NIL,其INSERT,SEARCH,DELETE的平均时间为O(1)。注意:如果散列表支持删除操作,为了能更快删除
    某一元素,应该将链表设计为双向链接的,如果表示单链接的,则为了删除元素e,首先必须在T[h(x.key)]中找到元素x，然后修改x前驱的next
    元素属性,把x从链表中删除,单链表情况下删除和查找操作的渐近运行时间相同。
    </p>
    <h5>开放寻址法</h5>
    <p>
    在开放寻址法中,所有元素都存放在散列表中。也就是说，每个表项或包含动态集合的一个元素，或包含NIL。当查找某个元素时，要系统地检查
    所有表项，直到找到所需的元素，或者最终查明该元素不在表中。不像链表，有一个链表头的指针在数组中，而元素都存放在散列表外,因此
    在开放寻址法中，散列表可以能会被填满,以至于不能插入任何新的元素，当然开放寻址法不用指针，而是计算出存取的槽序号。于是，不用
    存储指针而节约的空间可以用同样的空间来提供更多的槽，潜在地减少了冲突，提高了减速速度。
    但是针对删除操作时，处理删除会比较棘手。所以在必须做删除操作的应用中，常见的做法是采用链接法来解决冲突。
    开放寻址法中装载因子(动态集合元素/散列槽数）绝对不会大于1。
    </p>
    <p>
    在开放寻址法中，当要插入一个元素时，可以连续地检查散列表的个各项，直到找到一个空槽来放置这个元素为止。检查顺序可以是线性的，
    可以是二次的，也可以是再次散列的。
    </p>
    <p>
    查找关键字和插入关键字的算法基本上是一样的。
    </p>
    <p>
    在开放寻址法中，对散列表元素的删除操作执行起来比较困难。当我们从槽i中删除关键字时，不能仅将NIL置于其中来标识它为空。因为这样做的话，
    会导致在插入另外的关键字探查过程中，有可能无法检索某些关键字。这里有一个解决方法，就是在槽i中置一个特定的槽当作空槽，从而可以插入新元素。    
    </p>
    有三种技术常用来计算开放寻址法中的探查序列,线性探查,二次探查和双重探查。
    以下三种方法要做到降低集群现象的发生（即大量的元素密集的排列在散列表中的某一段区域，这样会增加插入查找的时间复杂度）。
    这三种技术中,双重散列产生的探查序列树最多,似乎能给出最好的结果。<以下摘自百科>
    <pre>
    1.线性探查给定一个普通的散列函数h’:U->{0,1,2…m-1}(称为辅助散列函数)，线性探查方法采用的散列函数为：
    h(k,i)=(h’(k)+i) mod m , i=0,1,2,…m-1给定一个关键字k，第一个探查的槽是T(h’(k)),接下来探查下一个槽，直到T[m-1]。
    线性探查方法比较容易实现，但存在一个问题,成为一次群集.随着时间的推移,连续被占用的槽不断增加,平均查找时间也随着不断增加.
    群集现象很容易出现，这是因为当一个空槽前有i个满的槽时，该空槽为下一个将被占用的槽的概率是(i+1)/m，
    连续被占用的槽的序列将会变得越来越长，因而平均查找时间也会随之增加。
    
    2.二次探查（quadratic probing）采用的形式如下：
    h(k,i)=(h’(k)+c1i+c2i)modm 其中h’是一个辅助散列函数，c1和c2为辅助常数，i=0,1,…m-1。
    初始的探查位置为T[h’(k)],后续的探查位置要在此基础上加上一个偏移量，
    该偏移量是以二次的方式依赖于探查号i的。如果两个关键字的初始探查位置是相同的，那么他们的后续二次探查的序列也是相同的。
    这种性质会导致一种程度较轻的群集现象，成为二次群集。
    
    3.双重散列是用在开放寻址法的最好方法之一，因为它所产生的排列具有随机选择的排列的许多特性。它采用如下形式的散列函数：
    h(k,i)=(h1(k)+i*h2(k))modm
    其中h1和h2是辅助散列函数。初始探查位置为T[h1(k)],后续的探查位置在此基础上加上偏移量h2(k)模m。
    与线性探查和二次探查不同的是，这里的探查序列以两种方式依赖于k，因为初始探查位置和偏移量都可能发生变化。    
    </pre>
</div>
