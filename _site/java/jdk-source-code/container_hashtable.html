<div class="blog">
    <h3>JDK1.8.0_66 源码之 HashTable</h3>
    <pre>
    //继承Dictionary 实现 Map
    public class Hashtable< K, V> extends Dictionary< K, V>
            implements Map< K, V>, Cloneable, java.io.Serializable {

        /**
         * The hash table data.
         */
        private transient Entry< ?, ?>[] table; //散列数组

        /**
         * The total number of entries in the hash table.
         */
        private transient int count;    //hash table 元素数量

        /**
         * The table is rehashed when its size exceeds this threshold.  (The
         * value of this field is (int)(capacity * loadFactor).)
         *
         * @serial
         */
        private int threshold;  //capacity * loadFactor 阀值,如果count大于此值则进行扩容 capacity*2 +1

        /**
         * The load factor for the hashtable.
         *
         * @serial
         */
        private float loadFactor;   //负载因子,指当前数组可以容纳元素的比例,默认0.75

        /**
         * The number of times this Hashtable has been structurally modified
         * Structural modifications are those that change the number of entries in
         * the Hashtable or otherwise modify its internal structure (e.g.,
         * rehash).  This field is used to make iterators on Collection-views of
         * the Hashtable fail-fast.  (See ConcurrentModificationException).
         */
        private transient int modCount = 0; //快速失效机制

        /** use serialVersionUID from JDK 1.0.2 for interoperability */
        private static final long serialVersionUID = 1421746759512286392L;  //序列化UID

        /**
         * Constructs a new, empty hashtable with the specified initial
         * capacity and the specified load factor.
         *
         * @param      initialCapacity   the initial capacity of the hashtable.
         * @param      loadFactor        the load factor of the hashtable.
         * @exception  IllegalArgumentException  if the initial capacity is less
         *             than zero, or if the load factor is nonpositive.
         */
        public Hashtable(int initialCapacity, float loadFactor) {
            if (initialCapacity < 0)
                throw new IllegalArgumentException("Illegal Capacity: "+
                                                   initialCapacity);
            if (loadFactor <= 0 || Float.isNaN(loadFactor))
                throw new IllegalArgumentException("Illegal Load: "+loadFactor);

            if (initialCapacity==0)
                initialCapacity = 1;
            this.loadFactor = loadFactor;
            table = new Entry<?,?>[initialCapacity];
            threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        }

        /**
         * Constructs a new, empty hashtable with the specified initial capacity
         * and default load factor (0.75).
         *
         * @param     initialCapacity   the initial capacity of the hashtable.
         * @exception IllegalArgumentException if the initial capacity is less
         *              than zero.
         */
        public Hashtable(int initialCapacity) {
            this(initialCapacity, 0.75f);
        }

        /**
         * Constructs a new, empty hashtable with a default initial capacity (11)
         * and load factor (0.75).
         */
        public Hashtable() {
            this(11, 0.75f);    //初始化hashtable数组大小为11,负载因子0.75
        }

        /**
         * Constructs a new hashtable with the same mappings as the given
         * Map.  The hashtable is created with an initial capacity sufficient to
         * hold the mappings in the given Map and a default load factor (0.75).
         *
         * @param t the map whose mappings are to be placed in this map.
         * @throws NullPointerException if the specified map is null.
         * @since   1.2
         */
        public Hashtable(Map< ? extends K, ? extends V > t) {
            this(Math.max(2*t.size(), 11), 0.75f);  //此处比较的是 2*t.size() ??? 为何不是 t.size()/3*t.size()
            putAll(t);
        }

        /**
         * Returns the number of keys in this hashtable.
         *
         * @return  the number of keys in this hashtable.
         */
        public synchronized int size() {    //注意此处是同步的
            return count;
        }

        /**
         * Tests if this hashtable maps no keys to values.
         *
         * @return  <code>true</code> if this hashtable maps no keys to values;
         *          <code>false</code> otherwise.
         */
        public synchronized boolean isEmpty() {
            return count == 0;
        }
        /**
         * Returns an enumeration of the keys in this hashtable.
         * @return  an enumeration of the keys in this hashtable.
         * @see     Enumeration
         * @see     #elements()
         * @see     #keySet()
         * @see     Map
         */
        public synchronized Enumeration< K > keys() {
            return this.< K >getEnumeration(KEYS);  //返回enumeration的keys,其实就是一个Iterator迭代器
        }

        /**
         * Returns an enumeration of the values in this hashtable.
         * Use the Enumeration methods on the returned object to fetch the elements
         * sequentially.
         * @return  an enumeration of the values in this hashtable.
         * @see     java.util.Enumeration
         * @see     #keys()
         * @see     #values()
         * @see     Map
         */
        public synchronized Enumeration< V > elements() {
            return this.< V >getEnumeration(VALUES);    //返回 enumeration 的values
        }
        /**
         * Tests if some key maps into the specified value in this hashtable.
         * This operation is more expensive than the {@link #containsKey
         * containsKey} method.
         * 判断value是否在hashtable数组中,从头向后遍历,注意只是比较了value
         */
        public synchronized boolean contains(Object value) {
            if (value == null) {
                throw new NullPointerException();
            }

            Entry<?,?> tab[] = table;
            for (int i = tab.length ; i-- > 0 ;) {
                for (Entry<?,?> e = tab[i] ; e != null ; e = e.next) {
                    if (e.value.equals(value)) {
                        return true;
                    }
                }
            }
            return false;
        }
        public boolean containsValue(Object value) {
            return contains(value);
        }
        //是否有对应的key,注意,比较key时要满足 hash值相等并且equals相等
        public synchronized boolean containsKey(Object key) {
            Entry<?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;   //hashtable 中计算下标的方案
            for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
                if ((e.hash == hash) && e.key.equals(key)) {//此处对key进行了hash比较,e.hash=e.key.hash
                    return true;
                }
            }
            return false;
        }
        //根据key得到V,如果不存在返回null
        public synchronized V get(Object key) {
            Entry<?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            for (Entry<?,?> e = tab[index] ; e != null ; e = e.next) {
                if ((e.hash == hash) && e.key.equals(key)) {
                    return (V)e.value;
                }
            }
            return null;
        }
        /**
         * Increases the capacity of and internally reorganizes this
         * hashtable, in order to accommodate and access its entries more
         * efficiently.  This method is called automatically when the
         * number of keys in the hashtable exceeds this hashtable's capacity
         * and load factor.
         */
        @SuppressWarnings("unchecked")
        protected void rehash() {           //当threshold(capacity * loadFactor) < count则扩容 2倍+1
            int oldCapacity = table.length;
            Entry< ?, ?>[] oldMap = table;

            // overflow-conscious code
            int newCapacity = (oldCapacity << 1) + 1;   //扩容 *2 + 1
            if (newCapacity - MAX_ARRAY_SIZE > 0) {
                if (oldCapacity == MAX_ARRAY_SIZE)
                    // Keep running with MAX_ARRAY_SIZE buckets
                    return;
                newCapacity = MAX_ARRAY_SIZE;
            }
            Entry< ?, ?>[] newMap = new Entry< ?, ?>[newCapacity];  //创建新Entry数组

            modCount++;
            threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);    //重新计算阀值
            table = newMap;

            for (int i = oldCapacity ; i-- > 0 ;) {     //将数组移植到新数组中
                for (Entry< K, V> old = (Entry< K, V>)oldMap[i] ; old != null ; ) {
                    Entry< K, V> e = old;
                    old = old.next;

                    int index = (e.hash & 0x7FFFFFFF) % newCapacity;    //重新计算元素在数组中的下标
                    e.next = (Entry< K, V>)newMap[index];
                    newMap[index] = e;
                }
            }
        }

        private void addEntry(int hash, K key, V value, int index) {
            modCount++;

            Entry< ?, ?> tab[] = table;
            if (count >= threshold) {
                // Rehash the table if the threshold is exceeded
                rehash();

                tab = table;
                hash = key.hashCode();
                index = (hash & 0x7FFFFFFF) % tab.length;
            }

            // Creates the new entry.
            @SuppressWarnings("unchecked")
            Entry< K, V> e = (Entry< K, V>) tab[index];
            tab[index] = new Entry<>(hash, key, value, e);  //注意此处:新的Entry放在最前面,形成新链,头插法
            count++;
        }

        public synchronized V put(K key, V value) {
            // Make sure the value is not null
            if (value == null) {
                throw new NullPointerException();
            }

            // Makes sure the key is not already in the hashtable.
            Entry< ?, ?> tab[] = table;
            int hash = key.hashCode();  //注意此处:key为null时,则JVM抛出NullPointerException();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K, V> entry = (Entry< K, V>)tab[index];
            for(; entry != null ; entry = entry.next) {
                if ((entry.hash == hash) && entry.key.equals(key)) {//如果存在相同的key则进行覆盖,并放回old Value
                    V old = entry.value;
                    entry.value = value;
                    return old;
                }
            }

            addEntry(hash, key, value, index);  //此处为头插法
            return null;  //新增key,value时则返回null
        }
        /**
         * Removes the key (and its corresponding value) from this
         * hashtable. This method does nothing if the key is not in the hashtable.
         *  如果hashtalbe存在key则返回对应的value,否则null
         * @param   key   the key that needs to be removed
         * @return  the value to which the key had been mapped in this hashtable,
         *          or <code>null</code> if the key did not have a mapping
         * @throws  NullPointerException  if the key is <code>null</code>
         */
        public synchronized V remove(Object key) {
            Entry< ?, ?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K, V> e = (Entry< K, V>)tab[index];
            for(Entry< K, V> prev = null ; e != null ; prev = e, e = e.next) {
                //注意此处比较的是Entry< K,V>的hash值以及key的equals()方法,
                //其实此处e的hash就是e.key的hashCode(),原因看put(K,V)方法

                if ((e.hash == hash) && e.key.equals(key)) {
                    modCount++;
                    if (prev != null) {
                        prev.next = e.next;
                    } else {
                        tab[index] = e.next;
                    }
                    count--;
                    V oldValue = e.value;
                    e.value = null;
                    return oldValue;
                }
            }
            return null;    //没找到返回null
        }
        /**
         * Copies all of the mappings from the specified map to this hashtable.
         * These mappings will replace any mappings that this hashtable had for any
         * of the keys currently in the specified map.
         *
         * @param t mappings to be stored in this map
         * @throws NullPointerException if the specified map is null
         * @since 1.2
         */
        public synchronized void putAll(Map< ? extends K, ? extends V> t) {
            for (Map.Entry< ? extends K, ? extends V> e : t.entrySet())
                put(e.getKey(), e.getValue());  //循环调用put(K,V)
        }
        /**
         * Clears this hashtable so that it contains no keys.
         */
        public synchronized void clear() {
            Entry<?,?> tab[] = table;
            modCount++;
            for (int index = tab.length; --index >= 0; )
                tab[index] = null;
            count = 0;
        }
        /**
         * Creates a shallow copy of this hashtable. All the structure of the
         * hashtable itself is copied, but the keys and values are not cloned.
         * This is a relatively expensive operation.
         *  注意:此处是浅层克隆
         * @return  a clone of the hashtable
         */
        public synchronized Object clone() {
            try {
                Hashtable< ?,?> t = (Hashtable< ?,?>)super.clone();
                t.table = new Entry< ?,?>[table.length];
                for (int i = table.length ; i-- > 0 ; ) {
                    t.table[i] = (table[i] != null)
                        ? (Entry< ?,?>) table[i].clone() : null;
                }
                t.keySet = null;
                t.entrySet = null;
                t.values = null;
                t.modCount = 0;
                return t;
            } catch (CloneNotSupportedException e) {
                // this shouldn't happen, since we are Cloneable
                throw new InternalError(e);
            }
        }

        public synchronized String toString() {
            int max = size() - 1;
            if (max == -1)
                return "{}";

            StringBuilder sb = new StringBuilder();
            Iterator< Map.Entry< K,V>> it = entrySet().iterator();//Entry< K,V>迭代器

            sb.append('{');
            for (int i = 0; ; i++) {
                Map.Entry< K,V> e = it.next();
                K key = e.getKey();
                V value = e.getValue();
                sb.append(key   == this ? "(this Map)" : key.toString());
                sb.append('=');
                sb.append(value == this ? "(this Map)" : value.toString());

                if (i == max)
                    return sb.append('}').toString();
                sb.append(", ");
            }
        }
        private < T> Enumeration< T> getEnumeration(int type) {
            if (count == 0) {
                return Collections.emptyEnumeration();  //hashtable空时返回
            } else {
                return new Enumerator<>(type, false);   //详情看最下面的Enumerator类,false表示返回Enumerator
            }
        }

        private < T> Iterator< T> getIterator(int type) {
            if (count == 0) {
                return Collections.emptyIterator();
            } else {
                return new Enumerator<>(type, true);    //true表示返回Iterator迭代器
            }
        }
        // Views

        /**
         * Each of these fields are initialized to contain an instance of the
         * appropriate view the first time this view is requested.  The views are
         * stateless, so there's no reason to create more than one of each.
         */
        private transient volatile Set< K> keySet;          //多线程共享的对象
        private transient volatile Set< Map.Entry< K,V>> entrySet;
        private transient volatile Collection< V> values;

        /**
         * Returns a {@link Set} view of the keys contained in this map.
         * The set is backed by the map, so changes to the map are
         * reflected in the set, and vice-versa.  If the map is modified
         * while an iteration over the set is in progress (except through
         * the iterator's own <tt>remove</tt> operation), the results of
         * the iteration are undefined.  The set supports element removal,
         * which removes the corresponding mapping from the map, via the
         * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,
         * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>
         * operations.  It does not support the <tt>add</tt> or <tt>addAll</tt>
         * operations.
         *
         * @since 1.2
         */
        public Set< K> keySet() {
            if (keySet == null)
                keySet = Collections.synchronizedSet(new KeySet(), this);
            return keySet;
        }
        private class KeySet extends AbstractSet< K> {
            public Iterator< K> iterator() {
                return getIterator(KEYS);   //KEYS迭代
            }
            public int size() {
                return count;
            }
            public boolean contains(Object o) {
                return containsKey(o);
            }
            public boolean remove(Object o) {
                return Hashtable.this.remove(o) != null;
            }
            public void clear() {
                Hashtable.this.clear();
            }
        }

        /**
         * Returns a {@link Set} view of the mappings contained in this map.
         * The set is backed by the map, so changes to the map are
         * reflected in the set, and vice-versa.  If the map is modified
         * while an iteration over the set is in progress (except through
         * the iterator's own <tt>remove</tt> operation, or through the
         * <tt>setValue</tt> operation on a map entry returned by the
         * iterator) the results of the iteration are undefined.  The set
         * supports element removal, which removes the corresponding
         * mapping from the map, via the <tt>Iterator.remove</tt>,
         * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
         * <tt>clear</tt> operations.  It does not support the
         * <tt>add</tt> or <tt>addAll</tt> operations.
         *
         * @since 1.2
         */
        public Set< Map.Entry< K,V>> entrySet() {
            if (entrySet==null)
                entrySet = Collections.synchronizedSet(new EntrySet(), this);
            return entrySet;
        }
        private class EntrySet extends AbstractSet< Map.Entry< K,V>> {
            public Iterator< Map.Entry< K,V>> iterator() {
                return getIterator(ENTRIES);    //Entry< K,V>迭代器
            }

            public boolean add(Map.Entry< K,V> o) {
                return super.add(o);
            }

            public boolean contains(Object o) {
                if (!(o instanceof Map.Entry))
                    return false;
                Map.Entry< ?,?> entry = (Map.Entry< ?,?>)o;
                Object key = entry.getKey();
                Entry< ?,?>[] tab = table;
                int hash = key.hashCode();
                int index = (hash & 0x7FFFFFFF) % tab.length;

                for (Entry< ?,?> e = tab[index]; e != null; e = e.next)
                    //采用key的hash以及entry的equals()比较是否相等,注意此处的比较是entry的equals()方法,
                    //如果为非原始类习惯则需要重写对象的equals(),以及hashCode()
                    if (e.hash==hash && e.equals(entry))
                        return true;
                return false;
            }

            public boolean remove(Object o) {
                if (!(o instanceof Map.Entry))
                    return false;
                Map.Entry< ?,?> entry = (Map.Entry< ?,?>) o;
                Object key = entry.getKey();
                Entry< ?,?>[] tab = table;
                int hash = key.hashCode();
                int index = (hash & 0x7FFFFFFF) % tab.length;

                @SuppressWarnings("unchecked")
                Entry< K,V> e = (Entry< K,V>)tab[index];
                for(Entry< K,V> prev = null; e != null; prev = e, e = e.next) {
                    if (e.hash==hash && e.equals(entry)) {//如果找到单链表删除操作
                        modCount++;
                        if (prev != null)
                            prev.next = e.next;
                        else
                            tab[index] = e.next;

                        count--;
                        e.value = null;
                        return true;
                    }
                }
                return false;
            }

            public int size() {
                return count;
            }

            public void clear() {
                Hashtable.this.clear();
            }
        }

        /**
         * Returns a {@link Collection} view of the values contained in this map.
         * The collection is backed by the map, so changes to the map are
         * reflected in the collection, and vice-versa.  If the map is
         * modified while an iteration over the collection is in progress
         * (except through the iterator's own <tt>remove</tt> operation),
         * the results of the iteration are undefined.  The collection
         * supports element removal, which removes the corresponding
         * mapping from the map, via the <tt>Iterator.remove</tt>,
         * <tt>Collection.remove</tt>, <tt>removeAll</tt>,
         * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not
         * support the <tt>add</tt> or <tt>addAll</tt> operations.
         *
         * @since 1.2
         */
        public Collection< V> values() {
            if (values==null)
                values = Collections.synchronizedCollection(new ValueCollection(),this);
            return values;
        }
        private class ValueCollection extends AbstractCollection< V> {
            public Iterator< V> iterator() {
                return getIterator(VALUES);     //VALUES迭代器
            }
            public int size() {
                return count;
            }
            public boolean contains(Object o) {
                return containsValue(o);
            }
            public void clear() {
                Hashtable.this.clear();
            }
        }

        // Comparison and hashing

        /**
         * Compares the specified Object with this Map for equality,
         * as per the definition in the Map interface.
         *
         * @param  o object to be compared for equality with this hashtable
         * @return true if the specified Object is equal to this Map
         * @see Map#equals(Object)
         * @since 1.2
         */
        public synchronized boolean equals(Object o) {
            if (o == this)
                return true;

            if (!(o instanceof Map))
                return false;
            Map< ?,?> t = (Map< ?,?>) o;
            if (t.size() != size())
                return false;

            try {
                Iterator< Map.Entry< K,V>> i = entrySet().iterator();
                while (i.hasNext()) {
                    Map.Entry< K,V> e = i.next();
                    K key = e.getKey();
                    V value = e.getValue();
                    if (value == null) {
                        if (!(t.get(key)==null && t.containsKey(key)))
                            return false;
                    } else {
                        if (!value.equals(t.get(key)))
                            return false;
                    }
                }
            } catch (ClassCastException unused)   {
                return false;
            } catch (NullPointerException unused) {
                return false;
            }

            return true;
        }
        /**
         * Returns the hash code value for this Map as per the definition in the
         * Map interface.
         *
         * @see Map#hashCode()
         * @since 1.2
         */
        public synchronized int hashCode() {
            /*
             * This code detects the recursion caused by computing the hash code
             * of a self-referential hash table and prevents the stack overflow
             * that would otherwise result.  This allows certain 1.1-era
             * applets with self-referential hash tables to work.  This code
             * abuses the loadFactor field to do double-duty as a hashCode
             * in progress flag, so as not to worsen the space performance.
             * A negative load factor indicates that hash code computation is
             * in progress.
             */
            int h = 0;
            if (count == 0 || loadFactor < 0)
                return h;  // Returns zero

            loadFactor = -loadFactor;  // Mark hashCode computation in progress
            Entry< ?,?>[] tab = table;
            for (Entry< ?,?> entry : tab) {
                while (entry != null) {
                    h += entry.hashCode();
                    entry = entry.next;
                }
            }

            loadFactor = -loadFactor;  // Mark hashCode computation complete

            return h;
        }
        @Override
        public synchronized V getOrDefault(Object key, V defaultValue) {
            V result = get(key);
            return (null == result) ? defaultValue : result;
        }
        //jdk1.8支持Lambda表达式
        @SuppressWarnings("unchecked")
        @Override
        public synchronized void forEach(BiConsumer< ? super K, ? super V> action) {
            Objects.requireNonNull(action);     // explicit check required in case
                                                // table is empty.
            final int expectedModCount = modCount;

            Entry< ?, ?>[] tab = table;
            for (Entry< ?, ?> entry : tab) {
                while (entry != null) {
                    action.accept((K)entry.key, (V)entry.value);
                    entry = entry.next;

                    if (expectedModCount != modCount) {
                        throw new ConcurrentModificationException();
                    }
                }
            }
        }
        @SuppressWarnings("unchecked")
        @Override
        public synchronized void replaceAll(BiFunction< ? super K, ? super V, ? extends V> function) {
            Objects.requireNonNull(function);     // explicit check required in case
                                                  // table is empty.
            final int expectedModCount = modCount;

            Entry< K, V>[] tab = (Entry< K, V>[])table;
            for (Entry< K, V> entry : tab) {
                while (entry != null) {
                    entry.value = Objects.requireNonNull(
                        function.apply(entry.key, entry.value));
                    entry = entry.next;

                    if (expectedModCount != modCount) {
                        throw new ConcurrentModificationException();
                    }
                }
            }
        }
        //jdk1.8支持
        @Override
        public synchronized V putIfAbsent(K key, V value) {
            Objects.requireNonNull(value);

            // Makes sure the key is not already in the hashtable.
            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> entry = (Entry< K,V>)tab[index];
            for (; entry != null; entry = entry.next) {
                if ((entry.hash == hash) && entry.key.equals(key)) {
                    V old = entry.value;
                    if (old == null) {      //此处value不应该不可能为null?? put(K,V)时不是进行控制了?
                        entry.value = value;//如果key对应的value为null在则赋值为value
                    }
                    return old;
                }
            }

            addEntry(hash, key, value, index);//未找到,则新增
            return null;
        }

        @Override
        public synchronized boolean remove(Object key, Object value) {
            Objects.requireNonNull(value);

            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> e = (Entry< K,V>)tab[index];
            for (Entry< K,V> prev = null; e != null; prev = e, e = e.next) {
                if ((e.hash == hash) && e.key.equals(key) && e.value.equals(value)) {
                    modCount++;
                    if (prev != null) {
                        prev.next = e.next;
                    } else {
                        tab[index] = e.next;
                    }
                    count--;
                    e.value = null;
                    return true;
                }
            }
            return false;
        }
        //如果根据key找到oldValue则替换为newValue
        @Override
        public synchronized boolean replace(K key, V oldValue, V newValue) {
            Objects.requireNonNull(oldValue);
            Objects.requireNonNull(newValue);
            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> e = (Entry< K,V>)tab[index];
            for (; e != null; e = e.next) {
                if ((e.hash == hash) && e.key.equals(key)) {
                    if (e.value.equals(oldValue)) {
                        e.value = newValue;
                        return true;
                    } else {
                        return false;
                    }
                }
            }
            return false;
        }

        @Override
        public synchronized V replace(K key, V value) {
            Objects.requireNonNull(value);
            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> e = (Entry< K,V>)tab[index];
            for (; e != null; e = e.next) {
                if ((e.hash == hash) && e.key.equals(key)) {
                    V oldValue = e.value;
                    e.value = value;
                    return oldValue;
                }
            }
            return null;
        }
        //暂时不理解
        @Override
        public synchronized V computeIfAbsent(K key, Function< ? super K, ? extends V> mappingFunction) {
            Objects.requireNonNull(mappingFunction);

            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> e = (Entry< K,V>)tab[index];
            for (; e != null; e = e.next) {
                if (e.hash == hash && e.key.equals(key)) {
                    // Hashtable not accept null value
                    return e.value;
                }
            }

            V newValue = mappingFunction.apply(key);
            if (newValue != null) {
                addEntry(hash, key, newValue, index);
            }

            return newValue;
        }
        //暂时不理解
        @Override
        public synchronized V computeIfPresent(K key, BiFunction< ? super K, ? super V, ? extends V> remappingFunction) {
            Objects.requireNonNull(remappingFunction);

            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> e = (Entry< K,V>)tab[index];
            for (Entry< K,V> prev = null; e != null; prev = e, e = e.next) {
                if (e.hash == hash && e.key.equals(key)) {
                    V newValue = remappingFunction.apply(key, e.value);
                    if (newValue == null) {
                        modCount++;
                        if (prev != null) {
                            prev.next = e.next;
                        } else {
                            tab[index] = e.next;
                        }
                        count--;
                    } else {
                        e.value = newValue;
                    }
                    return newValue;
                }
            }
            return null;
        }
        //暂时不理解
        @Override
        public synchronized V compute(K key, BiFunction< ? super K, ? super V, ? extends V> remappingFunction) {
            Objects.requireNonNull(remappingFunction);

            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> e = (Entry< K,V>)tab[index];
            for (Entry< K,V> prev = null; e != null; prev = e, e = e.next) {
                if (e.hash == hash && Objects.equals(e.key, key)) {
                    V newValue = remappingFunction.apply(key, e.value);
                    if (newValue == null) {
                        modCount++;
                        if (prev != null) {
                            prev.next = e.next;
                        } else {
                            tab[index] = e.next;
                        }
                        count--;
                    } else {
                        e.value = newValue;
                    }
                    return newValue;
                }
            }

            V newValue = remappingFunction.apply(key, null);
            if (newValue != null) {
                addEntry(hash, key, newValue, index);
            }

            return newValue;
        }
        //暂时不理解
        @Override
        public synchronized V merge(K key, V value, BiFunction< ? super V, ? super V, ? extends V> remappingFunction) {
            Objects.requireNonNull(remappingFunction);

            Entry< ?,?> tab[] = table;
            int hash = key.hashCode();
            int index = (hash & 0x7FFFFFFF) % tab.length;
            @SuppressWarnings("unchecked")
            Entry< K,V> e = (Entry< K,V>)tab[index];
            for (Entry< K,V> prev = null; e != null; prev = e, e = e.next) {
                if (e.hash == hash && e.key.equals(key)) {
                    V newValue = remappingFunction.apply(e.value, value);
                    if (newValue == null) {
                        modCount++;
                        if (prev != null) {
                            prev.next = e.next;
                        } else {
                            tab[index] = e.next;
                        }
                        count--;
                    } else {
                        e.value = newValue;
                    }
                    return newValue;
                }
            }

            if (value != null) {
                addEntry(hash, key, value, index);
            }

            return value;
        }

        /**
         * Save the state of the Hashtable to a stream (i.e., serialize it).
         *
         * @serialData The <i>capacity</i> of the Hashtable (the length of the
         *             bucket array) is emitted (int), followed by the
         *             <i>size</i> of the Hashtable (the number of key-value
         *             mappings), followed by the key (Object) and value (Object)
         *             for each key-value mapping represented by the Hashtable
         *             The key-value mappings are emitted in no particular order.
         */
        private void writeObject(java.io.ObjectOutputStream s)//序列化Hashtable
                throws IOException {
            Entry< Object, Object> entryStack = null;

            synchronized (this) {
                // Write out the length, threshold, loadfactor
                s.defaultWriteObject();

                // Write out length, count of elements
                s.writeInt(table.length);
                s.writeInt(count);

                // Stack copies of the entries in the table
                for (int index = 0; index < table.length; index++) {
                    Entry< ?,?> entry = table[index];

                    while (entry != null) {
                        entryStack =
                            new Entry<>(0, entry.key, entry.value, entryStack);
                        entry = entry.next;
                    }
                }
            }

            // Write out the key/value objects from the stacked entries
            while (entryStack != null) {
                s.writeObject(entryStack.key);
                s.writeObject(entryStack.value);
                entryStack = entryStack.next;
            }
        }
        /**
         * Reconstitute the Hashtable from a stream (i.e., deserialize it).
         */
        private void readObject(java.io.ObjectInputStream s)    //反序列化Hashtable
             throws IOException, ClassNotFoundException
        {
            // Read in the length, threshold, and loadfactor
            s.defaultReadObject();

            // Read the original length of the array and number of elements
            int origlength = s.readInt();
            int elements = s.readInt();

            // Compute new size with a bit of room 5% to grow but
            // no larger than the original size.  Make the length
            // odd if it's large enough, this helps distribute the entries.
            // Guard against the length ending up zero, that's not valid.
            int length = (int)(elements * loadFactor) + (elements / 20) + 3;
            if (length > elements && (length & 1) == 0)
                length--;
            if (origlength > 0 && length > origlength)
                length = origlength;
            table = new Entry< ?,?>[length];
            threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);
            count = 0;

            // Read the number of elements and then all the key/value objects
            for (; elements > 0; elements--) {
                @SuppressWarnings("unchecked")
                    K key = (K)s.readObject();
                @SuppressWarnings("unchecked")
                    V value = (V)s.readObject();
                // synch could be eliminated for performance
                reconstitutionPut(table, key, value);
            }
        }
        /**
         * The put method used by readObject. This is provided because put
         * is overridable and should not be called in readObject since the
         * subclass will not yet be initialized.
         *
         * <p>This differs from the regular put method in several ways. No
         * checking for rehashing is necessary since the number of elements
         * initially in the table is known. The modCount is not incremented
         * because we are creating a new instance. Also, no return value
         * is needed.
         */
        private void reconstitutionPut(Entry< ?,?>[] tab, K key, V value)
            throws StreamCorruptedException
            {
                if (value == null) {
                    throw new java.io.StreamCorruptedException();
                }
                // Makes sure the key is not already in the hashtable.
                // This should not happen in deserialized version.
                int hash = key.hashCode();
                int index = (hash & 0x7FFFFFFF) % tab.length;
                for (Entry< ?,?> e = tab[index] ; e != null ; e = e.next) {
                    if ((e.hash == hash) && e.key.equals(key)) {
                        throw new java.io.StreamCorruptedException();
                    }
                }
                // Creates the new entry.
                @SuppressWarnings("unchecked")
                Entry< K,V> e = (Entry< K,V>)tab[index];
                tab[index] = new Entry<>(hash, key, value, e);
                count++;
        }
        /**
        * Hashtable bucket collision list entry
        * 散列表桶中的Entry< K,V>对象
        */
        private static class Entry< K,V> implements Map.Entry< K,V> {
            final int hash;
            final K key;
            V value;
            Entry< K,V> next;
            //此处直接给了key对应的hash,并且为final,避免了重复计算hash,同时Entry对象的hash就是key对应的hash
            protected Entry(int hash, K key, V value, Entry< K,V> next) {
                this.hash = hash;
                this.key =  key;
                this.value = value;
                this.next = next;
            }

            @SuppressWarnings("unchecked")
            protected Object clone() {
                return new Entry< >(hash, key, value,
                    (next==null ? null : (Entry< K,V>) next.clone()));
            }

            // Map.Entry Ops

            public K getKey() {
                return key;
            }

            public V getValue() {
                return value;
            }

            public V setValue(V value) {    //此处新value覆盖oldValue
                if (value == null)
                    throw new NullPointerException();

                V oldValue = this.value;
                this.value = value;
                return oldValue;
            }

            public boolean equals(Object o) {   //比较了key & value值
                if (!(o instanceof Map.Entry))
                return false;
                Map.Entry< ?,?> e = (Map.Entry< ?,?>)o;

                return (key==null ? e.getKey()==null : key.equals(e.getKey())) &&
                        (value==null ? e.getValue()==null : value.equals(e.getValue()));
            }

            public int hashCode() {
                return hash ^ Objects.hashCode(value);
            }

            public String toString() {
                return key.toString()+"="+value.toString();
            }
        }
        // Types of Enumerations/Iterations
        private static final int KEYS = 0;
        private static final int VALUES = 1;
        private static final int ENTRIES = 2;

        /**
        * A hashtable enumerator class.  This class implements both the
        * Enumeration and Iterator interfaces, but individual instances
        * can be created with the Iterator methods disabled.  This is necessary
        * to avoid unintentionally increasing the capabilities granted a user
        * by passing an Enumeration.
        */
        private class Enumerator< T> implements Enumeration< T>, Iterator< T> {
            Entry< ?,?>[] table = Hashtable.this.table;
            int index = table.length;   //table长度
            Entry< ?,?> entry;  //数组中的头结点对象
            Entry< ?,?> lastReturned;   //最后返回的entry
            int type;   //上面进行了定义

            /**
            * Indicates whether this Enumerator is serving as an Iterator
            * or an Enumeration.  (true -> Iterator).
            */
            boolean iterator;

            /**
            * The modCount value that the iterator believes that the backing
            * Hashtable should have.  If this expectation is violated, the iterator
            * has detected concurrent modification.
            */
            protected int expectedModCount = modCount;  //保持同步

            Enumerator(int type, boolean iterator) {
                this.type = type;
                this.iterator = iterator;
            }

            public boolean hasMoreElements() {
                Entry< ?,?> e = entry;
                int i = index;
                Entry< ?,?>[] t = table;
                /* Use locals for faster loop iteration */
                while (e == null && i > 0) {
                    e = t[--i];
                }
                entry = e;
                index = i;
                return e != null;
            }

            @SuppressWarnings("unchecked")
            public T nextElement() {
                Entry< ?,?> et = entry;
                int i = index;
                Entry< ?,?>[] t = table;
                /* Use locals for faster loop iteration */
                while (et == null && i > 0) {
                    et = t[--i];
                }
                entry = et;
                index = i;
                if (et != null) {
                    Entry< ?,?> e = lastReturned = entry;
                    entry = e.next;
                    return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);
                }
                throw new NoSuchElementException("Hashtable Enumerator");
            }

            // Iterator methods
            public boolean hasNext() {
                return hasMoreElements();
            }

            public T next() {
                if (modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                return nextElement();
            }

            public void remove() {//单链表删除
                if (!iterator)
                    throw new UnsupportedOperationException();
                if (lastReturned == null)
                    throw new IllegalStateException("Hashtable Enumerator");
                if (modCount != expectedModCount)
                    throw new ConcurrentModificationException();

                synchronized(Hashtable.this) {
                    Entry< ?,?>[] tab = Hashtable.this.table;
                    int index = (lastReturned.hash & 0x7FFFFFFF) % tab.length;

                    @SuppressWarnings("unchecked")
                    Entry< K,V> e = (Entry< K,V>)tab[index];
                    for(Entry< K,V> prev = null; e != null; prev = e, e = e.next) {
                        if (e == lastReturned) {
                            modCount++;
                            expectedModCount++;
                            if (prev == null)
                                tab[index] = e.next;
                            else
                                prev.next = e.next;
                            count--;
                            lastReturned = null;
                            return;
                        }
                    }
                throw new ConcurrentModificationException();
                }
            }
        }

    }
    </pre>
    <h5>总结</h5>
    <pre>
    采用底层数组+单链表 实现了 Hashtable,同步,所以性能会受影响,key和value,均不能为null,添加值时如果key对应的value存在则覆盖。
    </pre>
</div>