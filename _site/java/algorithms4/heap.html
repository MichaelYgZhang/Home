<div class="blog">
    <h3>优先队列---堆的实现,以及堆排序</h3>
    <pre>
    /**
     *  基于数组实现的堆的优先队列
     *	TODO: 扩大/缩小 数组容量
     */
    public class Heap {
        private Heap(){}

        public static void sort(Comparable[] pq){
            int N = pq.length;
            for(int k = N/2; k>=1 ;k--)
                sink(pq, k ,N);                         //堆的构造
            while(N > 1){
                exch(pq, 1, N--);
                sink(pq, 1, N);                         //下沉排序
            }
        }
         /**
         * 由上至下的堆有序化-下沉(与子结点中大的交换)
         */
        private static void sink(Comparable[] pq, int k, int N){
            while(2*k <= N){
                int j = 2*k;
                if(j < N && less(pq, j, j+1)) j++;		    //ture:表示右结点更大,与大的交换
                if(!less(pq, k, j)) break;				    //子结点小于父结点则break
                exch(pq, k, j);							    //上面两个if都false,则与左子结点交换
                k = j;									    // 此时交换后的位置为 j
            }
        }

        private static boolean less(Comparable[] pq, int i, int j){
            return pq[i-1].compareTo(pq[j-1]) < 0;
        }

        private static void exch(Object[] pq, int i, int j){
            Object swap = pq[i-1];
            pq[i-1] = pq[j-1];
            pq[j-1] = swap;
        }

        private static boolean less(Comparable v, Comparable w){
            return v.compareTo(w) < 0;
        }

        private static boolean isSorted(Comparable[] a){
            for(int i = 1; i < a.length; i++)
                if(less(a[i], a[i-1])) return false;
            return true;
        }

        private static void show(Comparable[] a){
            for(int i=0; i < a.length; i++){
                System.out.print(a[i] + " ");
            }
        }
    }
    </pre>
</div>
