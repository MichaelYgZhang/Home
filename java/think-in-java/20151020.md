### 第1章 对象导论
20151021
### 第2章 一切都是对象   
### 第3章 操作符
### 第5章 初始化与清理
初始化指Java的构造器。
清理指GC，Java垃圾回收，JVM通常有以下工作方式
1:引用计数器(未被使用于JVM中,原因:效率低,耗内存)
2:依据思想:对任何'活'的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。之后可以遍历所有引用,然后没有引用的将被标记,
  全部遍历完成之后进行清理。
3:自适应的，分代的，停止-复制，标记-清扫 垃圾回收器。JVM还附加了其他技术以提升速度比如JIT,惰性评估等优化技术。

### 第6章 访问权限控制 
  主要是讲述如何正确使用包,以及public,protected,包访问权限(没有关键字),private的使用。
### 第7章 复用类
  总结:继承和组合都能从现有类型生成新类型。组合一般是将现有类型作为新类型底层实现的一部分来加以复用,而继承复用的是接口。
  一般来说开始设计时一般优先选择使用组合(或者使用代理)，只在确实必要时才使用继承。因为组合更具灵活性。如果设计过于复杂，通常做法是将现有模块拆分为更小的部分，其中每个类都有具体的用途，而且既不会太大也不会太小。
组合优先选择而后是继承。
  
### 2015-11-15由于项目紧,多天未更新！
### 第8章 多态
  多态通过分离做什么和怎么做，从另一个 角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能创建可扩展程序--即无论在项目最初创建时还是在需要添加新功能时都可以"生长"出新程序。
### 第9章 接口
  
### 第10章 内部类(未读完)
### 第11章 持有对象
  --2015-11-22
  -主要是集合方面的知识点
  -持有对象List集合
  -2015-11-26
  -总结:java提供了大量的持有对象的方式:

1.  )数组将数字与对象联系起来。它保持类型明确的对象，查询对象时，不需要对结果做类型转换。
    -它可以是多维的，可以保存基本类型的数据。但是，数组一旦生成，其容量就不能改变。
2. )Collection 保持单一的元素，而Map保存相关联的键值对。有了Java泛型，你就可以指定容器中存放的对象类型，因此你就不会
    -将错误的类型的对象放置到容器中，而且在从容器中获取元素时，不必进行类型转换。各种Collection和各种Map都可以在你向
    -其中添加更多的元素时，自动调整其尺寸。容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到容器中
    -所持有的包装类型之间的双向转换。
3. )像数组一样，List也建立数字索引与对象的关联，因此，数组和List都是排好序的容器。List能够自动扩充容量。
4. )如果要进行大量的随机访问，就是用ArrayList；如果要经常从表中间插入或者删除元素，则应该使用LinkedList。
5. )各种Queue以及栈的行为,由LinkedList提供支持。
6. )Map是一种将对象(而非数字)与对象相关联的设计。HashMap设计用来快速访问；而TreeMap保持‘键’始终处于排序状态，
    所以没有HashMap快。LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问能力。
7. )Set不接受重复元素。HashSet提供最快的查询速度，而TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。
8. )新程序中不应该使用过时的Vector,Hashtable和Stack。
  

### 第12章  通过异常处理错误
 2015-11-27未读完
  总结:异常使用指南

1. )在其当的级别处理问题。(在知道该如何处理的情况下才捕获异常)
2. )解决问题并且重新调用产生异常的方法。
3. )进行少许修补，然后绕过异常放生的地方继续执行。
4. )用别的数据进行计算，以代替方法预计会返回的值。
5. )把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。
6. )把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。
7. )终止程序。
8. )进行简化。
9. )让类库和程序更安全。

异常处理的优点之一就是它使得你可以在某处集中精力处理你要解决的问题,而在另一处处理你编写的这段代码中产生的错误。
尽管异常通常被认为是一种工具，使得你可以在运行时报告错误并从错误中"恢复",以及它的"报告"功能是异常的精髓所在。一致的
错误报告系统意味着，你再也不必对所写的每段代码，都质问自己"错误是否正在成为漏网之鱼？"。异常处理将会帮助你来捕获错误。

### 第13章 字符串
可以证明，字符串操作是计算机程序设计中最常见的行为。
未读完

### 第14章 类型信息
  运行时类型信息使得你可以在程序运行时发现和使用类型信息。
  注:这一章的知识点看完了,不是非常明白，改天再仔细读一遍。

### 第15章 泛型
    泛型的使用:
    1-泛型类
    public class Genericity<T>{
      private T t;
      public Genericity(){}
      public Genericity(T t){this.t = t;}
      public set(T t){this.t = t;}
      public get(){return t;}
      public String toString(){return t.toString();}
      public static void main(String[] args){
        Genericity<someObjectA> gA = new Genericity(someObjectA);
        Genericity<someObjectB> gB = new Genericity(someObjectB);
      }
    }
    注意:<T>,括号中可以是多个元组,比如声明泛型对象时,可以是:public class Genericity<A,B>{},或者public class Genericity<A,B,C>{}
    等等,任意多个。并且泛型对象之间也是可以进行继承的
    2-泛型接口
    与普通接口类似，只是写法不同。
    3-泛型方法
    public Class GenericMethods{
      public <T> void f(T x){
        System.out.print(x.getClass().getName(););
      }
      public static void main(String[] args){
        GenericMethods g = new GenericMethods();
        g.f("");//java.lang.String
        g.f(1);//java.lang.Integer
        g.f(1.0);//java.lang.Double
        g.f(1.0F);//java.lang.Folat
        ....
      }
    }
    4-使用泛型能创建一些通用的类。
    比如:
    public class CreateCollections{
      public static <K,V> Map<K,V> map(){return new HashMap<K,V>();}
      public static <T> List<T> list(){return new ArrayList<T>();}
      public static <T> LinkedList<T> lList(){return new LinkedList<T>();}
      public static <T> Set<T>  set(){return new HashSet<T>();}
      pubilc static <T> Queue<T> queue(){return new LinedList<T>():}
    }
    5-可变参数与泛型方法
    public class GenericVarargs{
      public static <T> List<T> makeList(T... args){ 
        List<T> result = new ArrayList<T>();
        for(T item : args ){
          result.add(item);
        }
        return result;
      }
      public static void main(String[] args){
        List<String> ls = makeList("A");
        ls = makeList("A","B","C");
        ....
      }
    }
    6- 泛型中擦除的神秘之处
    7-泛型边界之extends
    注意:通配符被限制为单一边界
    8-通配符在泛型当中的使用
    例如: List<? extends Fruit> flist = new ArrayList<Apple>();//Apple extends Fruit;
        超类型通配符:List<? super MyClass>  甚至或者使用类型参数   <? super T> 
    9-泛型问题:
      1.任何基本类型都不能作为类型参数。不过对于基本类型Java SE5以后就有自动包装机制。

  .........泛型未完！
  2015-12-28更新,因最近忙于看JDK1.8源码,未能继续读书！
  16:数组
    注:当你使用最近的Java版本编程时,应该"优选容器而不是数组"！！,只有在已证明性能成为问题(并且切换到数组对性能提高有帮助)
      时,你才应该将程序重构为使用数组。
  17:容器深入研究
    容器相关知识点还在继续看JDK1.8的源码,持续更新中....目前已看完ArrayList,HashMap,以及集合类的接口Collection,Iterator...
  
  18:JAVA I/O系统
  暂停。。。
  19:枚举类型
  暂停。。。。
  20:注解
    注解:也被称为元数据,为我们在代码中添加信息提供了一种形式化的方法,使我们可以在稍后某个时刻非常方便地使用这些元素。
  	
  	   @Target           	| 表示该注解可以用于什么地方,可能的ElementType参数包括:
	                    	| CONSTRUCTOR:构造器的声明
	                    	| FIELD:域声明
	                    	| LOCAL_VARIABLE:局部变量声明
	                    	| METHOD:方法声明
	                    	| PACKAGE:包声明
	                    	| PARAMETER:参数声明
	                    	| TYPE:类，接口(包括注解类型)或enum声明
	  @Retention        	| 表示需要在什么级别保存该注解信息。可以选的RetentionPolicy参数包括:
	                    	| SOURCE:注解将被编译器丢弃
	                    	| CLASS: 注解在class文件中可用，但会被VM丢弃。
	                    	| RUNTIME:VM将在运行期也保留注解,因此可以通过反射机制读取注解的信息。
	  @Documented       	| 将此注解包含在Javadoc中
	  @Inherited        	| 允许子类继承父类的注解
  
  
  
  
  





  
  
  
  
