<div class="blog">
    <h3>设计模式之Prototype Pattern</h3>
    <p>
    原型链模式动机:在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，
        然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。
    </p>
    <pre>
    原型链模式定义:使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。
    原型模式包含如下角色：
        Prototype：抽象原型类
        ConcretePrototype：具体原型类
        Client：客户类
    </pre>
    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Prototype_UML.svg/600px-Prototype_UML.svg.png">
    <h5>模式分析:</h5>
    <pre>
    1 在原型模式结构中定义了一个抽象原型类，所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。
        因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆，Java语言中的原型模式实现很简单。
    2 能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制。如果一个类没有实现这个接口但是调用了clone()方法，
        Java编译器将抛出一个CloneNotSupportedException异常。
    通常情况下，一个类包含一些成员对象，在使用原型模式克隆对象时，根据其成员对象是否也克隆，原型模式可以分为两种形式：深克隆和浅克隆。

    浅克隆比较简单:1 implements Cloneable
                 2 //使用clone()方法实现浅克隆
                   public Object clone()
                   {
                          Object obj = null;
                          try
                          {
                                 obj = super.clone();
                                 return (Object)obj;
                          }
                          catch(CloneNotSupportedException  e)
                          {
                                 System.out.println("不支持复制！");
                                 return null;
                          }
                   }

    深层克隆:1 implements Serializable & Cloneable
            2 //使用序列化技术实现深克隆
               public Object deepClone() throws  IOException, ClassNotFoundException, OptionalDataException
               {
                      //将对象写入流中
                      ByteArrayOutputStream bao=new  ByteArrayOutputStream();
                      ObjectOutputStream oos=new  ObjectOutputStream(bao);
                      oos.writeObject(this);

                      //将对象从流中取出
                      ByteArrayInputStream bis=new  ByteArrayInputStream(bao.toByteArray());
                      ObjectInputStream ois=new  ObjectInputStream(bis);
                      return  (Object)ois.readObject();
               }

    </pre>
    <h5>总结:</h5>
    <pre>
    优点:
        (1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。
        (2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。
        (3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。
        (4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。

    缺点:
        (1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。
        (2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。

    适用场景:
        (1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。
        (2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。
        (3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。
    </pre>

    <a href="http://blog.csdn.net/lovelion/article/details/17517213">参考</a>

    <script id="dsq-count-scr" src="//michaelzhangblog.disqus.com/count.js" async></script>
    <div id="disqus_thread"></div>
    <script>
        /**
         * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
         */
        var disqus_config = function () {
            this.page.url = 'http://michaelygzhang.github.io/home/'; // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = 'prototype'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');

            s.src = '//michaelzhangblog.disqus.com/embed.js';

            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

</div>