<div class="blog">
    <h3>深入理解类的生命周期</h3>

    <h4>类的加载-->连接(验证->准备->解析)-->初始化</h4>

    <h5>类的加载</h5>
    <p>
    类的加载是指把类的.class文件中的二进制数据读入到内存中,把它存放在运行时数据区的方法区内，然后在堆区创建一个
    java.lang.Class对象,用来封装类在方法区内的数据结构。
    </p>
    <p>
    java虚拟机能够从多种来源加载类的二进制数据到内存中,包括:
<pre>
    1:从本地文件系统中加载类的.class文件。
    2:通过网络下载类的.class文件。
    3:从ZIP,JAR或者其他类型的归类文件中提取.class文件。
    4:从一个专有数据库中提取.class文件。
    5:把一个Java源文件动态编译为.class文件。
</pre>
    类的加载由类的加载器完成，类加载器并不需要等到某个类被首次主动使用时才加载它，Java虚拟机允许类加载器在预料某个类将要
    被使用时就预先加载它，如果在预先加载过程中遇到.class文件缺失或者存在错误，类加载器必须等到程序首次主动使用该类时才
    报告错误(抛出LinkageError)。如果这个类一直没有被程序主动使用，那么类加载器将不会报告错误。
    </p>

    <h5>连接(类的验证)</h5>
    <p>
    当类被加载后，就进入连接阶段。连接就是把已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
    为了保护虚拟机的运行时环境,类的验证能够提高程序的健壮性，确保程序被安全地执行。
<pre>
    类的验证主要包括以下内容:
    1:类文件的结构检查，确保类文件遵从Java类文件的固定格式。
        比如:二进制文件是否以魔数0xCAFFBABE开头，主次版本是否在本虚拟机处理范围。。等
    2:语义检查:确保类本身符合java语言的语法规定，比如验证final类型的类没有子类，以及final类型的方法没有被覆盖..等
    3:字节码验证:确保字节码流可以被java虚拟机安全地执行。
    4:....等还有很多验证的
</pre>
    类的验证保证了安全性，却消耗了性能，如果所运行的代码都已被反复使用和验证过，那么实施阶段就可以考虑
    使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
    </p>

    <h5>连接(类的准备)</h5>
    <p>
    在类的准备阶段，java虚拟机为类的静态(static)变量分配内存，并设置默认的初始值。所使用的内存都在方法区中进行分配。
<pre>
    public class Sample{
        private static int a =1;//类加载阶段,为a分配4个字节的内存空间,并赋默认值0,赋值为1时是在初始化阶段执行。
        private static long b;//类加载阶段,为b分配8字节的内存空间,并赋默认值0.0
    }
</pre>
    注意:此时只有static修饰的静态变量才分配内存在方法区中,而实例变量,是随着对象实例化时一起分配到java堆中的。
    </p>

    <h5>连接(类的解析)</h5>
    <p>
    在解析阶段，java虚拟机会把累的二进制数据中的符号引用替换为直接引用。
<pre>
    举例:Student类的sport()方法会引用到Person类的run()方法。
    public void sport(){
        person.run();
    }
</pre>
    Student类的二进制数据中，包含了一个对Person类的run()方法的符号引用，它由run()方法的全名和
    相关描述符组成，在解析阶段，java虚拟机会把这个符号引用替换为一个指针，该指针指向Person类的
    run()方法在方法区的内存位置，这个指针就是直接引用。
    </p>

    <h5>类的初始化阶段</h5>
    <p>
    在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。静态变量初始化有两种途径:1,在静态变量的声明处进行初始化；
    2,在静态代码库中进行初始化。
<pre>
    public class Sample{
        private static int a = 1;//在静态变量的声明处进行初始化
        public static long b;
        public static long c;
        static{
            b = 2;//静态代码块中进行初始化
            ...
        }
        ...
    }
</pre>
    注意:静态变量的声明语句，以及静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类文件的
    先后顺序依次执行。
<pre>
    public class Sample{
        static int a = 1;
        static {
            a = 3;
        }
        static {
            a = 6;
        }
        public static void main(String args[]){
            System.out.print("a="+a);//打印6
        }
    }
</pre>
    </p>
    <h5>JVM初始化类的步骤</h5>
<pre>
    1:如果这个类未进行加载和连接，那就先进行加载和连接。
    2:如果这个类存在直接弗雷，并且这个父类还没有被初始化,先初始化这个直接父类。
    3:如果这个类存在初始化语句，就依次执行这些语句。
    当初初始化父类时也是这样的步骤。以确保程序当程序主动使用一个类时，这个类及其所有父类(直接/间接)都已经被初始化。
</pre>
</div>