<div class="blog">
    <h3>深入理解类的生命周期</h3>

    <h4>类的加载-->连接(验证->准备->解析)-->初始化</h4>

    <h5>类的加载</h5>
    <p>
    类的加载是指把类的.class文件中的二进制数据读入到内存中,把它存放在运行时数据区的方法区内，然后在堆区创建一个
    java.lang.Class对象,用来封装类在方法区内的数据结构。
    </p>
    <p>
    java虚拟机能够从多种来源加载类的二进制数据到内存中,包括:
<pre>
    1:从本地文件系统中加载类的.class文件。
    2:通过网络下载类的.class文件。
    3:从ZIP,JAR或者其他类型的归类文件中提取.class文件。
    4:从一个专有数据库中提取.class文件。
    5:把一个Java源文件动态编译为.class文件。
</pre>
    类的加载由类的加载器完成，类加载器并不需要等到某个类被首次主动使用时才加载它，Java虚拟机允许类加载器在预料某个类将要
    被使用时就预先加载它，如果在预先加载过程中遇到.class文件缺失或者存在错误，类加载器必须等到程序首次主动使用该类时才
    报告错误(抛出LinkageError)。如果这个类一直没有被程序主动使用，那么类加载器将不会报告错误。
    </p>

    <h5>连接(类的验证)</h5>
    <p>
    当类被加载后，就进入连接阶段。连接就是把已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
    为了保护虚拟机的运行时环境,类的验证能够提高程序的健壮性，确保程序被安全地执行。
<pre>
    类的验证主要包括以下内容:
    1:类文件的结构检查，确保类文件遵从Java类文件的固定格式。
        比如:二进制文件是否以魔数0xCAFFBABE开头，主次版本是否在本虚拟机处理范围。。等
    2:语义检查:确保类本身符合java语言的语法规定，比如验证final类型的类没有子类，以及final类型的方法没有被覆盖..等
    3:字节码验证:确保字节码流可以被java虚拟机安全地执行。
    4:....等还有很多验证的
</pre>
    类的验证保证了安全性，却消耗了性能，如果所运行的代码都已被反复使用和验证过，那么实施阶段就可以考虑
    使用-Xverify:none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。
    </p>

    <h5>连接(类的准备)</h5>
    <p>
    在类的准备阶段，java虚拟机为类的静态(static)变量分配内存，并设置默认的初始值。所使用的内存都在方法区中进行分配。
<pre>
    public class Sample{
        private static int a =1;//类加载阶段,为a分配4个字节的内存空间,并赋默认值0,赋值为1时是在初始化阶段执行。
        private static long b;//类加载阶段,为b分配8字节的内存空间,并赋默认值0.0
    }
</pre>
    注意:此时只有static修饰的静态变量才分配内存在方法区中,而实例变量,是随着对象实例化时一起分配到java堆中的。
    </p>

    <h5>连接(类的解析)</h5>
    <p>
    在解析阶段，java虚拟机会把累的二进制数据中的符号引用替换为直接引用。
<pre>
    举例:Student类的sport()方法会引用到Person类的run()方法。
    public void sport(){
        person.run();
    }
</pre>
    Student类的二进制数据中，包含了一个对Person类的run()方法的符号引用，它由run()方法的全名和
    相关描述符组成，在解析阶段，java虚拟机会把这个符号引用替换为一个指针，该指针指向Person类的
    run()方法在方法区的内存位置，这个指针就是直接引用。
    </p>

    <h5>类的初始化阶段</h5>
    <p>
    在初始化阶段，java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。静态变量初始化有两种途径:1,在静态变量的声明处进行初始化；
    2,在静态代码库中进行初始化。
<pre>
    public class Sample{
        private static int a = 1;//在静态变量的声明处进行初始化
        public static long b;
        public static long c;
        static{
            b = 2;//静态代码块中进行初始化
            ...
        }
        ...
    }
</pre>
    注意:静态变量的声明语句，以及静态代码块都被看做类的初始化语句，java虚拟机会按照初始化语句在类文件的
    先后顺序依次执行。
<pre>
    public class Sample{
        static int a = 1;
        static {
            a = 3;
        }
        static {
            a = 6;
        }
        public static void main(String args[]){
            System.out.print("a="+a);//打印6
        }
    }
</pre>
    </p>
    <h5>JVM初始化类的步骤</h5>
<pre>
    1:如果这个类未进行加载和连接，那就先进行加载和连接。
    2:如果这个类存在直接父类，并且这个父类还没有被初始化,先初始化这个直接父类。
    3:如果这个类存在初始化语句，就依次执行这些语句。
    当初初始化父类时也是这样的步骤。以确保程序当程序主动使用一个类时，这个类及其所有父类(直接/间接)都已经被初始化。
</pre>

    <h5>类的初始化的时机</h5>
    <p>
    Java虚拟机只有在程序首次主动使用一个类或者接口时才会初始化它。以下活动被看作是程序对类或接口的主动使用:
<pre>
    1:创建类的实例，包括，用new语句创建实例，或者通过反射，克隆以及反序列化手段来创建实例。
    2:调用类的静态方法。
    3:访问某个类或接口的静态变量，或者对该静态变量赋值。
    4:调用JavaAPI中某些反射方法，比如调用Class.forName("Student")方法，假如Student类还没有被初始化，那么
      forName()方法就会初始化Student类，然后返回代表这个Student类的Class实例。forName()方法是java.lang.Class
      类的静态方法。
    5:初始化一个类的子类。例如对Sub类的初始化,可以看做是对它父类Base类的主动使用，因此会先初始化Base类。
    6:Java虚拟机启动时被标明为启动类。
</pre>
    以下举例说明:

<pre>
    1) 对于final类型的静态变量，如果在编译时就能计算出变量的值，那么这种变量被看做编译时常量，
       Java程序对类的编译时常量的使用，被看做是对类的被动使用，不会导致类的初始化。
    class Tester{
        //a是编译时常量(能在编译时计算出变量的值),如果使用它,不会初始化Tester类
        public static final int a = 2*3;
        //b不是编译时常量,如果使用它,被看做是对类的主动使用
        public static final int b = (int)(Math.random()*5);
        static{
            System.out.println("Tester init!");
        }
    }
    public class Sample{
        public static void main(String args[]){
            System.out.println("a="+Tester.a);//打印 a= 6; 此时不初始化Tester类
            System.out.println("b="+Tester.b);//jvm当作是对类Tester的主动使用，进行初始化
            //打印 Tester init!
            //     b=xxx   此处的值是随机数
        }
    }

    2) 当Java虚拟机初始化一个类时,要求它的所有父类都已被初始化，但是这条规则不适用于接口。
        a.在初始化一个类时，并不会先初始化它所实现的接口。
        b.在初始化一个接口时，并不会先初始化它的父接口。

    3) 只有当程序访问的静态变量或静态方法的确在当前类或接口中定义时，才看做是对类或者接口的主动使用。

    4) 调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。
       调用Class类的静态方法forName("ClassXX")方法显式初始化ClassXX时，才是对ClassXX的主动使用，
       将导致ClassXX被初始化，静态代码块也会被执行。
</pre>

    </p>
</div>