<dvi class="blog">
    <h3>JDK1.8_0_66 HashSet源码解析</h3>
    <pre>
    注:HashSet实现比较简单主要都是调用了HashMap的方法
    public class HashSet< E> extends AbstractSet< E>
            implements Set< E>, Cloneable, java.io.Serializable
    {
        static final long serialVersionUID = -5024744406713321676L;
        private transient HashMap< E,Object> map;   //hashset的实现就是调用的hashmap的实现
        // Dummy value to associate with an Object in the backing Map
        //存储时put(k,v)对应的v值,因为map中的k值是唯一的所以hashset集合元素也是唯一的
        private static final Object PRESENT = new Object();
        /**
         * Constructs a new, empty set; the backing HashMap instance has
         * default initial capacity (16) and load factor (0.75).
         */
        public HashSet() {
            map = new HashMap< >();//构造方法就是直接返回一个hashmap对象,初始化容量16加载因子0.75
        }
        /**
         * Constructs a new set containing the elements in the specified
         * collection.  The HashMap is created with default load factor
         * (0.75) and an initial capacity sufficient to contain the elements in
         * the specified collection.
         *
         * @param c the collection whose elements are to be placed into this set
         * @throws NullPointerException if the specified collection is null
         */
        public HashSet(Collection< ? extends E> c) {
            map = new HashMap< >(Math.max((int) (c.size()/.75f) + 1, 16));//用大的作为初始容量
            addAll(c);
        }
        /**
         * Constructs a new, empty set; the backing HashMap instance has
         * the specified initial capacity and the specified load factor.
         *
         * @param      initialCapacity   the initial capacity of the hash map
         * @param      loadFactor        the load factor of the hash map
         * @throws     IllegalArgumentException if the initial capacity is less
         *             than zero, or if the load factor is nonpositive
         */
        public HashSet(int initialCapacity, float loadFactor) {
            //自定义初始化参数,如果已知容量大小,最好使用此方法,避免扩容时的性能消耗
            map = new HashMap< >(initialCapacity, loadFactor);
        }
        /**
         * Constructs a new, empty set; the backing HashMap instance has
         * the specified initial capacity and default load factor (0.75).
         *
         * @param      initialCapacity   the initial capacity of the hash table
         * @throws     IllegalArgumentException if the initial capacity is less
         *             than zero
         */
        public HashSet(int initialCapacity) {
            map = new HashMap< >(initialCapacity);//初始化容量,默认加载因子0.75
        }
        /**
         * Constructs a new, empty linked hash set.  (This package private
         * constructor is only used by LinkedHashSet.) The backing
         * HashMap instance is a LinkedHashMap with the specified initial
         * capacity and the specified load factor.
         *
         * @param      initialCapacity   the initial capacity of the hash map
         * @param      loadFactor        the load factor of the hash map
         * @param      dummy             ignored (distinguishes this
         *             constructor from other int, float constructor.)
         * @throws     IllegalArgumentException if the initial capacity is less
         *             than zero, or if the load factor is nonpositive
         */
        HashSet(int initialCapacity, float loadFactor, boolean dummy) {
            //包级构造方法只有创建其子类LinkedHashSet时才使用
            map = new LinkedHashMap< >(initialCapacity, loadFactor);
        }
        /**
         * Returns an iterator over the elements in this set.  The elements
         * are returned in no particular order.
         *
         * @return an Iterator over the elements in this set
         * @see ConcurrentModificationException
         */
        public Iterator< E> iterator() {
            return map.keySet().iterator();//因为只是存了key值,所有遍历时只用返回keySet()迭代器
        }
        /**
         * Returns the number of elements in this set (its cardinality).
         *
         * @return the number of elements in this set (its cardinality)
         */
        public int size() {
            return map.size();
        }
        /**
         * Returns true if this set contains no elements.
         *
         * @return true if this set contains no elements
         */
        public boolean isEmpty() {
            return map.isEmpty();
        }
        /**
         * Returns true if this set contains the specified element.
         * More formally, returns true if and only if this set
         * contains an element e such that
         * (o==null?e==null:o.equals(e)).
         *
         * @param o element whose presence in this set is to be tested
         * @return true if this set contains the specified element
         */
        public boolean contains(Object o) {
            return map.containsKey(o);
        }
        /**
         * Adds the specified element to this set if it is not already present.
         * More formally, adds the specified element e to this set if
         * this set contains no element e2 such that
         * (e==null?e2==null:e.equals(e2)).
         * If this set already contains the element, the call leaves the set
         * unchanged and returns false.
         *
         * @param e element to be added to this set
         * @return true if this set did not already contain the specified
         * element
         */
        public boolean add(E e) {
            return map.put(e, PRESENT)==null;//此处value值是一个final类型的Object对象
        }
        /**
         * Removes the specified element from this set if it is present.
         * More formally, removes an element e such that
         * (o==null?e==null:o.equals(e)),
         * if this set contains such an element.  Returns true if
         * this set contained the element (or equivalently, if this set
         * changed as a result of the call).  (This set will not contain the
         * element once the call returns.)
         *
         * @param o object to be removed from this set, if present
         * @return true if the set contained the specified element
         */
        public boolean remove(Object o) {
            //map的remove(o)方法返回key对应的value值,与put(k,PRESENT)对应
            return map.remove(o)==PRESENT;
        }
        /**
         * Removes all of the elements from this set.
         * The set will be empty after this call returns.
         */
        public void clear() {
            map.clear();
        }
        /**
         * Returns a shallow copy of this HashSet instance: the elements
         * themselves are not cloned.
         *
         * @return a shallow copy of this set
         */
        @SuppressWarnings("unchecked")
        public Object clone() {
            try {
                HashSet< E> newSet = (HashSet< E>) super.clone();
                newSet.map = (HashMap< E, Object>) map.clone();
                return newSet;
            } catch (CloneNotSupportedException e) {
                throw new InternalError(e);
            }
        }
        /**
         * Save the state of this HashSet instance to a stream (that is,
         * serialize it).
         *
         * @serialData The capacity of the backing HashMap instance
         *             (int), and its load factor (float) are emitted, followed by
         *             the size of the set (the number of elements it contains)
         *             (int), followed by all of its elements (each an Object) in
         *             no particular order.
         */
        private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
            // Write out any hidden serialization magic
            s.defaultWriteObject();

            // Write out HashMap capacity and load factor
            s.writeInt(map.capacity());
            s.writeFloat(map.loadFactor());

            // Write out size
            s.writeInt(map.size());

            // Write out all elements in the proper order.
            for (E e : map.keySet())
                s.writeObject(e);
        }
        /**
         * Reconstitute the HashSet instance from a stream (that is,
         * deserialize it).
         * 注意读的顺序与写的顺序对应,以及读取过程中的特殊处理
         */
        private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
            // Read in any hidden serialization magic
            s.defaultReadObject();

            // Read capacity and verify non-negative.
            int capacity = s.readInt();
            if (capacity < 0) {
                throw new InvalidObjectException("Illegal capacity: " +
                                                 capacity);
            }

            // Read load factor and verify positive and non NaN.
            float loadFactor = s.readFloat();
            if (loadFactor <= 0 || Float.isNaN(loadFactor)) {
                throw new InvalidObjectException("Illegal load factor: " +
                                                 loadFactor);
            }

            // Read size and verify non-negative.
            int size = s.readInt();
            if (size < 0) {
                throw new InvalidObjectException("Illegal size: " +
                                                 size);
            }

            // Set the capacity according to the size and load factor ensuring that
            // the HashMap is at least 25% full but clamping to maximum capacity.
            capacity = (int) Math.min(size * Math.min(1 / loadFactor, 4.0f),
                    HashMap.MAXIMUM_CAPACITY);

            // Create backing HashMap
            map = (((HashSet< ?>)this) instanceof LinkedHashSet ?
                   new LinkedHashMap< E,Object>(capacity, loadFactor) :
                   new HashMap< E,Object>(capacity, loadFactor));

            // Read in all elements in the proper order.
            for (int i=0; i< size; i++) {
                @SuppressWarnings("unchecked")
                    E e = (E) s.readObject();
                map.put(e, PRESENT);
            }
        }
        /**
         * Creates a late-binding = and fail-fast {@link Spliterator} over the elements in this set.
         * The {@code Spliterator} reports {@link Spliterator#SIZED} and
         * {@link Spliterator#DISTINCT}.  Overriding implementations should document
         * the reporting of additional characteristic values.
         * 支持Lambda表达式,函数式编程
         * @return a {@code Spliterator} over the elements in this set
         * @since 1.8
         */
        public Spliterator< E> spliterator() {
            return new HashMap.KeySpliterator< E,Object>(map, 0, -1, 0, 0);
        }
     }
    </pre>
    <h5>总结:</h5>
    <pre>
    根据源码可以看出hashset其实就是一个hashmap,只是在在添加元素的时候对应的put(k,object),k就是要添加的值,因为调用的
    Map.put(k,v)方法所有hashset有唯一这一特性,而参数v就是一个final类型的object对象。
    此处需要注意的是:由于map允许有一个key为null的键值对，所以set也就允许有一个为null的对象，唯一的一个。
    </pre>
</dvi>