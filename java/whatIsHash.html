<div class="blog">
    <h3>什么是Hash？它解决什么问题？Hash算法有哪些？</h3>
    <a href="http://www.serve.net/buz/hash.adt/java.000.html">Hashing-1</a>
    <a href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Hashing/">Hashing-2</a>
    以下资料摘自《算法导论》 第11章:散列表
    <h5>直接寻址表</h5>
    <p>
    直接寻址表顾名思义,就是用普通数组直接进行寻址的数组,其能在最坏O(1)时间内访问数组中的任意位置,不过它的缺点非常明显,
    当数据量比较小时,它简单有效,当比较大时,则不太实际,或者当数组空间很大而元素很少,则对空间造成了浪费。
    所以针对数组的不足,有了以下散列表,散列表是数组概念的推广,散列表即延续了数组的直接寻址快速的特点,又弥补了大数据时的不足。
    </p>
    <h5>散列表</h5>
    <p>
    在散列方式下,一个元素存放在下标h(k)中,即利用散列函数h,由关键字k计算出下标的位置,这里函数h将关键字k映射到散列表T数组的下标中,
    此处h(k)为关键字k的散列值。
    这里存在一个问题,两个关键可能映射为同一散列值,即同一下标位置上,这种情况称之为冲突,一般的解决方案为1:链接法 2:开放寻址法;
    </p>
    <h5>散列函数</h5>
    <p>
    散列函数是散列表性能的重要因素,常见的有用除法进行散列和用乘法进行散列,以及全域散列。乘/除法的散列方法比较简单,就是把当前
    的关键字先转为自然数,然后进行 取余/取模 运算或者移位运算等。
    如果一恶意对手来针对特定的散列函数选择要散列的关键字,那么他将n个关键字全部散列到同一槽中,使得平均检索时间为O(n),任何一特定
    的散列函数都可能出现这种最坏情况.唯一有效的改进方法是随机选择散列函数,使之独立于要存储的关键字,这种方法称为全域散列法。
    不管对手选择了怎样的关键字,其平均性能都很好。
    当然以上的所有散列函数都应精心设计。
    </p>
    <h5>链表法</h5>
    <p>
    链表法中把散列到同一槽中的所有元素都放在一个链表中,槽x(某一下标)中有一个指针,它指向存储所有散列到x的元素的链表的表头,
    如果不存在这样的元素,则槽x中为NIL,其INSERT,SEARCH,DELETE的平均时间为O(1)。注意:如果散列表支持删除操作,为了能更快删除
    某一元素,应该将链表设计为双向链接的,如果表示单链接的,则为了删除元素e,首先必须在T[h(x.key)]中找到元素x，然后修改x前驱的next
    元素属性,把x从链表中删除,单链表情况下删除和查找操作的渐近运行时间相同。
    </p>
    <h5>开发寻址法</h5>
    <p>
    未完待续    
    </p>
</div>
