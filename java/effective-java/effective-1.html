<div class="blog">
    <h3>第二章:创建和销毁对象</h3>
    <h5>第1条:考虑用静态工厂方法代替 构造器</h5>
    <pre>
优点:
    静态工厂方法与构造器不同的第一大优势在于,它们有名称。
    静态工厂方法与构造器不同的第二大优势在于,不必在每次调用它们的时候都创建一个新对象。
    静态工厂方法与构造器不同的第三大优势在于,它们可以返回原返回类型的任何子类型的对象。
    静态工厂方法与构造器不同的第四大优势在于,在创建参数化类型实例的时候,它们使代码变得更简洁。
例子:
    Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;String,List&lt;String&gt;&gt;();//bad
    Map&lt;String,List&lt;String&gt;&gt; map = HashMap.newInstance();//good
    public static &lt;K,V&gt; HashMap&lt;K,V&gt; newInstacnce(){
        return new HashMap&lt;K,V&gt;();
    }
缺点:
    静态工厂方法的主要缺点在于,类如果不含公有的或者受保护的构造器,就不能被子类化。
    静态工厂方法的第二个缺点在于,它们与其他的静态方法实际上没有任何区别。
    </pre>
    <h5>第2条:遇到多个构造器参数时要考虑构建器</h5>
    <pre>
    方案一:重叠构造器
    第一个只有必要参数的构造器,第二个有一个可选参数的构造器,第三个有两个可选参数的构造器,以此类推。
    缺点:采用重叠构造器模式可行,但是当有许多参数时,客户端代码会很难编写,并且仍然较难以阅读,
         并且参数顺序必须保持一致,也看不出来时什么意思。
    方案二:JavaBeans模式
    这种模式下,调用无参构造器创建对象,然后调用setter方法设置每个必要或可选参数。
    缺点:因为构造的过程中使用多个setter方法,所以构造过程被分到几个调用中,在构造的过程中JavaBean可能处于不一致的状态。
         并且需要程序员付出额外的努力确保setter期间的线程安全。
    方案三:Builder模式(在多个构造器参数时的最佳解决方案)
        
    </pre>
</div>