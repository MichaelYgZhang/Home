<div class="blog">
    <h3>第三章:对于所有对象都通用的方法</h3>
    <h5>第8条:覆盖equals时请遵守通用约定</h5>
    <pre>
    ->类的每个实例本质上都是唯一的。
    ->不关心类是否提供了"逻辑相等"的测试功能。
    ->超类已经覆盖了equals，从超类继承过来的行为对于子类也很合适。
    ->类是私有的或是包级私有的，可以确定它的equlas方法永远不会被调用。
    ->equals方法的通用约定。
        1:子反性,对于任何非null的引用值x，x.equals(x)必须返回true.
        2:对称性
        3:传递性
        4:一致性
    ->对于任何非null的引用值x,x.equals(null)必须返回false。
    ->覆盖equals时总要覆盖hashCode
    ->不要企图让equals方法过于智能。
    </pre>
    <h5>第9条:覆盖equals时总要覆盖hashCode</h5>
    <pre>
    ->Object规范【JavaSE6】
        1:在应用程序的执行期间,只要对象的equals方法的比较操作所用的信息没有被修改,那么
            对这同一对象调用多次，hashCode方法都必须始终如一地返回同一整数,在同一个应用程序的
            多次执行过程中,每次执行所返回的整数可以不一致。
        2:如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象的任意一个对象的hashCode
            方法都必须产生相同的整数结果。相等的对象必须有相等的散列码(hash code)
        3:如果两个对象的equals(Object)方法比较是不相等的，那么调用这两个对象中任意一个对象的
            hashCode方法，则不一定要产生不同的整数结果。
     注意:不要试图从散列码计算中排除掉一个对象的关键部分来提高性能。
    </pre>
    <h5>第10条:始终要覆盖toString</h5>
    <pre>
    ->java.lang.Object默认提供的toString()方法格式: 类名@十六进制数 , 根据toString的通用约定指出
        被返回的字符串应该"简洁的，但信息丰富，并且易于阅读",默认的提供的方法并不易于阅读,建议所有
        子类都覆盖这个方法！
    </pre>
    <h5>第11条:谨慎地覆盖clone</h5>
    <h5>第12条:考虑实现Comparable接口</h5>
    <pre>
    ->标准Comparable接口的方法compareTo(Object o),该对象小于，等于，大于指定对象时，分别返回一个负数整数,零,或者正整数。
        如果由于指定对象的类型无法与该对象进行比较，则抛出ClassCastException异常。
    注意:如果一个域没有实现Comparable接口，或者你需要使用一个非标准的排序关系,就可以使用一个显示的Comparator来代替.
        Comparable与类的耦合度更高,而Comparator接口则更好些。
    </pre>
</div>